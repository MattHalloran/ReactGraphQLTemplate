{"version":3,"file":"index.min.js","sources":["../src/index.js"],"sourcesContent":["let candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n  'details>summary',\n];\nlet candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nlet matches =\n  typeof Element === 'undefined'\n    ? function () {}\n    : Element.prototype.matches ||\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  let regularTabbables = [];\n  let orderedTabbables = [];\n\n  let candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  let candidate;\n  let candidateTabindex;\n  for (let i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) {\n      continue;\n    }\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  let tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map((a) => a.node)\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node) ||\n    isNonTabbableRadio(node) ||\n    getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node)) {\n    return false;\n  }\n  return true;\n}\n\nlet focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  let tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  }\n\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) {\n    return 0;\n  }\n\n  // in Chrome, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0\n  if (\n    (node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO') &&\n    node.getAttribute('tabindex') === null\n  ) {\n    return 0;\n  }\n\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || node.ownerDocument;\n  let radioSet = radioScope.querySelectorAll(\n    'input[type=\"radio\"][name=\"' + node.name + '\"]'\n  );\n  let checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return (\n    node.offsetParent === null || getComputedStyle(node).visibility === 'hidden'\n  );\n}\n\nexport { tabbable, isTabbable, isFocusable };\n"],"names":["candidateSelectors","candidateSelector","join","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","isNodeMatchingSelectorTabbable","node","isNodeMatchingSelectorFocusable","isInput","type","isRadio","name","checked","nodes","form","i","length","getCheckedRadio","ownerDocument","querySelectorAll","isTabbableRadio","isNonTabbableRadio","getTabindex","disabled","isHiddenInput","offsetParent","getComputedStyle","visibility","isHidden","focusableCandidateSelector","concat","tabindexAttr","parseInt","getAttribute","isNaN","contentEditable","isContentEditable","nodeName","tabIndex","sortOrderedTabbables","a","b","documentOrder","tagName","Error","call","el","options","candidate","candidateTabindex","regularTabbables","orderedTabbables","candidates","includeContainer","Array","slice","apply","unshift","push","sort","map"],"mappings":"aAAA,IAAIA,EAAqB,CACvB,QACA,SACA,WACA,UACA,SACA,aACA,kBACA,kBACA,mDACA,mBAEEC,EAAoCD,EAAmBE,KAAK,KAE5DC,EACiB,oBAAZC,QACH,aACAA,QAAQC,UAAUF,SAClBC,QAAQC,UAAUC,mBAClBF,QAAQC,UAAUE,sBA8CxB,SAASC,EAA+BC,YAEnCC,EAAgCD,IAuFrC,SAA4BA,UAJ5B,SAAiBA,UACRE,EAAQF,IAAuB,UAAdA,EAAKG,KAItBC,CAAQJ,KAWjB,SAAyBA,OAClBA,EAAKK,YACD,MAMLC,EAhBN,SAAyBC,EAAOC,OACzB,IAAIC,EAAI,EAAGA,EAAIF,EAAMG,OAAQD,OAC5BF,EAAME,GAAGH,SAAWC,EAAME,GAAGD,OAASA,SACjCD,EAAME,GAaHE,EAJKX,EAAKQ,MAAQR,EAAKY,eACXC,iBACxB,6BAA+Bb,EAAKK,KAAO,MAELL,EAAKQ,aACrCF,GAAWA,IAAYN,EApBNc,CAAgBd,GAvFvCe,CAAmBf,IACnBgB,EAAYhB,GAAQ,GAiBxB,SAASC,EAAgCD,WACnCA,EAAKiB,UA2DX,SAAuBjB,UACdE,EAAQF,IAAuB,WAAdA,EAAKG,KA5DRe,CAAclB,IA2FrC,SAAkBA,UAIQ,OAAtBA,EAAKmB,cAA+D,WAAtCC,iBAAiBpB,GAAMqB,WA/FXC,CAAStB,IAMvD,IAAIuB,EAA6BhC,EAAmBiC,OAAO,UAAU/B,KAAK,KAW1E,SAASuB,EAAYhB,OACfyB,EAAeC,SAAS1B,EAAK2B,aAAa,YAAa,WAEtDC,MAAMH,GA+Bb,SAA2BzB,SACO,SAAzBA,EAAK6B,gBA1BRC,CAAkB9B,GACb,EASY,UAAlBA,EAAK+B,UAA0C,UAAlB/B,EAAK+B,UACD,OAAlC/B,EAAK2B,aAAa,YAKb3B,EAAKgC,SAHH,EAlBAP,EAwBX,SAASQ,EAAqBC,EAAGC,UACxBD,EAAEF,WAAaG,EAAEH,SACpBE,EAAEE,cAAgBD,EAAEC,cACpBF,EAAEF,SAAWG,EAAEH,SAOrB,SAAS9B,EAAQF,SACS,UAAjBA,EAAKqC,4BAjDd,SAAqBrC,OACdA,QACG,IAAIsC,MAAM,2BAEqC,IAAnD5C,EAAQ6C,KAAKvC,EAAMuB,IAGhBtB,EAAgCD,uBAzBzC,SAAoBA,OACbA,QACG,IAAIsC,MAAM,2BAE4B,IAA1C5C,EAAQ6C,KAAKvC,EAAMR,IAGhBO,EAA+BC,qBA9DxC,SAAkBwC,EAAIC,GACpBA,EAAUA,GAAW,OAcjBC,EACAC,EAbAC,EAAmB,GACnBC,EAAmB,GAEnBC,EAAaN,EAAG3B,iBAAiBrB,GAEjCiD,EAAQM,kBACNrD,EAAQ6C,KAAKC,EAAIhD,KACnBsD,EAAaE,MAAMpD,UAAUqD,MAAMC,MAAMJ,IAC9BK,QAAQX,OAMlB,IAAI/B,EAAI,EAAGA,EAAIqC,EAAWpC,OAAQD,IAGhCV,EAFL2C,EAAYI,EAAWrC,MAOG,KAD1BkC,EAAoB3B,EAAY0B,IAE9BE,EAAiBQ,KAAKV,GAEtBG,EAAiBO,KAAK,CACpBhB,cAAe3B,EACfuB,SAAUW,EACV3C,KAAM0C,YAKQG,EACjBQ,KAAKpB,GACLqB,KAAI,SAACpB,UAAMA,EAAElC,QACbwB,OAAOoB"}