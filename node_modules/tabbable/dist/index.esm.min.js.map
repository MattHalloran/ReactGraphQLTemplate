{"version":3,"file":"index.esm.min.js","sources":["../src/index.js"],"sourcesContent":["let candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n  'details>summary',\n];\nlet candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nlet matches =\n  typeof Element === 'undefined'\n    ? function () {}\n    : Element.prototype.matches ||\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  let regularTabbables = [];\n  let orderedTabbables = [];\n\n  let candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  let candidate;\n  let candidateTabindex;\n  for (let i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) {\n      continue;\n    }\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  let tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map((a) => a.node)\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node) ||\n    isNonTabbableRadio(node) ||\n    getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node)) {\n    return false;\n  }\n  return true;\n}\n\nlet focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  let tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  }\n\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) {\n    return 0;\n  }\n\n  // in Chrome, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0\n  if (\n    (node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO') &&\n    node.getAttribute('tabindex') === null\n  ) {\n    return 0;\n  }\n\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || node.ownerDocument;\n  let radioSet = radioScope.querySelectorAll(\n    'input[type=\"radio\"][name=\"' + node.name + '\"]'\n  );\n  let checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return (\n    node.offsetParent === null || getComputedStyle(node).visibility === 'hidden'\n  );\n}\n\nexport { tabbable, isTabbable, isFocusable };\n"],"names":["candidateSelectors","candidateSelector","join","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","tabbable","el","options","candidate","candidateTabindex","regularTabbables","orderedTabbables","candidates","querySelectorAll","includeContainer","call","Array","slice","apply","unshift","i","length","isNodeMatchingSelectorTabbable","getTabindex","push","documentOrder","tabIndex","node","sort","sortOrderedTabbables","map","a","concat","isNodeMatchingSelectorFocusable","isInput","type","isRadio","name","checked","nodes","form","getCheckedRadio","ownerDocument","isTabbableRadio","isNonTabbableRadio","isTabbable","Error","disabled","isHiddenInput","offsetParent","getComputedStyle","visibility","isHidden","focusableCandidateSelector","isFocusable","tabindexAttr","parseInt","getAttribute","isNaN","contentEditable","isContentEditable","nodeName","b","tagName"],"mappings":"AAAA,IAAIA,EAAqB,CACvB,QACA,SACA,WACA,UACA,SACA,aACA,kBACA,kBACA,mDACA,mBAEEC,EAAoCD,EAAmBE,KAAK,KAE5DC,EACiB,oBAAZC,QACH,aACAA,QAAQC,UAAUF,SAClBC,QAAQC,UAAUC,mBAClBF,QAAQC,UAAUE,sBAExB,SAASC,EAASC,EAAIC,GACpBA,EAAUA,GAAW,OAcjBC,EACAC,EAbAC,EAAmB,GACnBC,EAAmB,GAEnBC,EAAaN,EAAGO,iBAAiBf,GAEjCS,EAAQO,kBACNd,EAAQe,KAAKT,EAAIR,KACnBc,EAAaI,MAAMd,UAAUe,MAAMC,MAAMN,IAC9BO,QAAQb,OAMlB,IAAIc,EAAI,EAAGA,EAAIR,EAAWS,OAAQD,IAGhCE,EAFLd,EAAYI,EAAWQ,MAOG,KAD1BX,EAAoBc,EAAYf,IAE9BE,EAAiBc,KAAKhB,GAEtBG,EAAiBa,KAAK,CACpBC,cAAeL,EACfM,SAAUjB,EACVkB,KAAMnB,YAKQG,EACjBiB,KAAKC,GACLC,KAAI,SAACC,UAAMA,EAAEJ,QACbK,OAAOtB,GAKZ,SAASY,EAA+BK,YAEnCM,EAAgCN,IAuFrC,SAA4BA,UAJ5B,SAAiBA,UACRO,EAAQP,IAAuB,UAAdA,EAAKQ,KAItBC,CAAQT,KAWjB,SAAyBA,OAClBA,EAAKU,YACD,MAMLC,EAhBN,SAAyBC,EAAOC,OACzB,IAAIpB,EAAI,EAAGA,EAAImB,EAAMlB,OAAQD,OAC5BmB,EAAMnB,GAAGkB,SAAWC,EAAMnB,GAAGoB,OAASA,SACjCD,EAAMnB,GAaHqB,EAJKd,EAAKa,MAAQb,EAAKe,eACX7B,iBACxB,6BAA+Bc,EAAKU,KAAO,MAELV,EAAKa,aACrCF,GAAWA,IAAYX,EApBNgB,CAAgBhB,GAvFvCiB,CAAmBjB,IACnBJ,EAAYI,GAAQ,GAOxB,SAASkB,EAAWlB,OACbA,QACG,IAAImB,MAAM,2BAE4B,IAA1C9C,EAAQe,KAAKY,EAAM7B,IAGhBwB,EAA+BK,GAGxC,SAASM,EAAgCN,WACnCA,EAAKoB,UA2DX,SAAuBpB,UACdO,EAAQP,IAAuB,WAAdA,EAAKQ,KA5DRa,CAAcrB,IA2FrC,SAAkBA,UAIQ,OAAtBA,EAAKsB,cAA+D,WAAtCC,iBAAiBvB,GAAMwB,WA/FXC,CAASzB,IAMvD,IAAI0B,EAA6BxD,EAAmBmC,OAAO,UAAUjC,KAAK,KAC1E,SAASuD,EAAY3B,OACdA,QACG,IAAImB,MAAM,2BAEqC,IAAnD9C,EAAQe,KAAKY,EAAM0B,IAGhBpB,EAAgCN,GAGzC,SAASJ,EAAYI,OACf4B,EAAeC,SAAS7B,EAAK8B,aAAa,YAAa,WAEtDC,MAAMH,GA+Bb,SAA2B5B,SACO,SAAzBA,EAAKgC,gBA1BRC,CAAkBjC,GACb,EASY,UAAlBA,EAAKkC,UAA0C,UAAlBlC,EAAKkC,UACD,OAAlClC,EAAK8B,aAAa,YAKb9B,EAAKD,SAHH,EAlBA6B,EAwBX,SAAS1B,EAAqBE,EAAG+B,UACxB/B,EAAEL,WAAaoC,EAAEpC,SACpBK,EAAEN,cAAgBqC,EAAErC,cACpBM,EAAEL,SAAWoC,EAAEpC,SAOrB,SAASQ,EAAQP,SACS,UAAjBA,EAAKoC"}